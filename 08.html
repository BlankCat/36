<!DOCTYPE HTML>
<html>
	<head>
		<title>java 36</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">
			<div id="wrapper" class="fade-in">
					<div id="intro">
						<h1>This is<br />
						java </h1>
						<p>article of java  <a href="http://blankcat.github.io/">@BlankCat</a> for <a href="http://blankcat.github.io/">Home page</a><br />
						address:<a href="http://blankcat.github.io/">http://blankcat.github.io/</a>.</p>
						<ul class="actions">
							<li><a href="#header" class="button icon solo fa-arrow-down scrolly">Continue</a></li>
						</ul>
					</div>
					<header id="header">
						<a href="index.html" class="logo">BlankCat</a>
					</header>
						<!-- Nav -->
					<nav id="nav" style="overflow-x: scroll;">
						<ul class="links">
							<li class="active"><a href="index.html">01</a></li>
							<li><a href="02.html">02</a></li>
							<li><a href="03.html">03</a></li>
							<li><a href="04.html">04</a></li>
							<li><a href="05.html">05</a></li>
							<li><a href="06.html">06</a></li>
							<li><a href="07.html">07</a></li>
							<li><a href="08.html">08</a></li>
							<li><a href="09.html">09</a></li>
							<li><a href="10.html">10</a></li>
							<li><a href="11.html">11</a></li>
							<li><a href="12.html">12</li>
							<li><a href="13.html">13</a></li>
							<li><a href="14.html">14</a></li>
							<li><a href="15.html">15</a></li>
							<li><a href="16.html">16</a></li>
							<li><a href="17.html">17</a></li>
							<li><a href="18.html">18</a></li>
							<li><a href="19.html">19</a></li>
							<li><a href="20.html">20</a></li>
							<li><a href="21.html">21</a></li>
							<li><a href="22.html">22</a></li>
							<li><a href="23.html">23</li>
							<li><a href="24.html">24</a></li>
							<li><a href="25.html">25</a></li>
							<li><a href="26.html">26</a></li>
							<li><a href="27.html">27</a></li>
							<li><a href="28.html">28</a></li>
							<li><a href="29.html">29</a></li>
							<li><a href="30.html">30</a></li>
							<li><a href="31.html">31</a></li>
							<li><a href="32.html">32</a></li>
							<li><a href="33.html">33</a></li>
							<li><a href="34.html">34</a></li>
							<li><a href="35.html">35</a></li>
							<li><a href="36.html">36</a></li>
							<li><a href="37.html">37</a></li>
							<li><a href="38.html">38</a></li>
							<li><a href="39.html">39</a></li>
							<li><a href="40.html">40</a></li>
						</ul>
						<ul class="icons">
							<li><a href="https://github.com/BlankCat" class="icon fa-github"><span class="label">GitHub</span></a></li>
						</ul>
					</nav>
					<div id="main">
							<article class="post featured">
								<p>09-vector-arraylist-linkedlist区别 集合框架 云计算任务调度系统，希望优先处理VIP客户。 利用那些数据结构和标准的集合框架 类似的场景都基于那些数据结构？</p>
<p>在这个题目下， 自然就会想到优先级队列了，但还需要额外考虑vip再分级， 即同等级vip的平权的问题， 所以应该考虑除了直接的和vip等级相关的优先级队列优先级规则问题， 还得考虑同等级多个客户互相不被单一客户大量任务阻塞的问题， 数据结构确实是基础，即便这个思考题考虑的这个场景，待调度数据估计会放在redis里面吧 回复 赞</p>
<p>精选第一个对于读写效率问题，我觉得表述有问欠缺，或者说不能那么绝对。 1、并不是所有的增删都会开辟新内存，没有开辟新内存的尾部增，效率也是杠杠的。 2、尾部删除也不需要开辟新内存，只是移出最后一个对象。 之前我也是接收了ArrayList的特性随机访问快，增删效率差。直到看到源码才知道，没那么绝对。 直接导致结果就是本身适合使用ArrayList的场景会因为这个笼统的说法而选LinkedList</p>
<p>Collection接口的声明是带范型的，其中定义的Object[ ] toArray()方法为什么不是范型方式的？有什么原因吗？ 回复 按照javadoc，我觉得这个方法设计目的，就是让调用者精确控制类型； 里面声明了，toArray(new Object[0])等同于toArray()</p>
<p>（<strong><em>线性数据结构</em></strong>） Vector、ArrayList、LinkedList均为【线型的数据结构】， 但是从实现方式与应用场景中又存在差别。 1 底层实现方式 ArrayList内部用数组来实现； LinkedList内部采用双向链表实现； Vector内部用数组实现。 2 读写机制 【扩容方式/删除元素/查找元素】 ArrayList在执行插入元素是超过当前数组预定义的最大值时， 数组需要扩容，扩容过程需要调用底层System.arraycopy()方法进行大量的数组复制操作； 在删除元素时并不会减少数组的容量（如果需要缩小数组容量，可以调用trimToSize()方法）； 在查找元素时要遍历数组，对于非null的元素采取equals的方式寻找。</p>
<pre><code>LinkedList在插入元素时，须创建一个新的Entry对象，并更新相应元素的前后元素的引用；
在查找元素时，需遍历链表；
在删除元素时，要遍历链表，找到要删除的元素，然后从链表上将此元素删除即可。

Vector与ArrayList仅在插入元素时容量扩充机制不一致。
对于Vector，默认创建一个大小为10的Object数组，并将capacityIncrement设置为0；
当插入元素数组大小不够时，如果capacityIncrement大于0，则将Object数组的大小扩大为现有size+capacityIncrement；
如果capacityIncrement&lt;=0,则将Object数组的大小扩大为现有大小的2倍。</code></pre>
<p>3 读写效率 ArrayList对元素的增加和删除都会引起数组的内存分配空间动态发生变化。 因此，对其进行插入和删除速度较慢，但检索速度很快。 LinkedList由于基于链表方式存放数据，增加和删除元素的速度较快，但是检索速度较慢。</p>
<p>4 线程安全性 ArrayList、LinkedList为非线程安全； Vector是基于synchronized实现的线程安全的ArrayList。</p>
<p>需要注意的是： 单线程应尽量使用ArrayList，Vector因为同步会有性能损耗； 即使在多线程环境下， 我们可以利用Collections这个类中为我们提供的 synchronizedList(List list)方法返回一个线程安全的同步列表对象。</p>
<p>利用PriorityBlockingQueue或Disruptor可实现基于任务优先级为调度策略的执行调度系统。</p>
<p> 既然是Java的主题，那就用PriorityBlockingQueue吧。 如果是真实场景肯定会考虑高可用能持久化的方案。 其实我觉得应该参考 银行窗口，同时三个窗口，就是三个队列，银台就是消费者线程， 某一个窗口vip优先，没有vip时也为普通客户服务。 要实现，要么有个dispatcher，要么保持vip通道不许普通进入，vip柜台闲时从其他队列偷 回复 有道理</p>
<p>java集合类底层基本上就是基于数组或者链表来实现的， 数组的地址连续性决定了其随机存取速度较快， 但是涉及到扩容则比较耗时， 而链表则不存在扩容的性能消耗，但随机访问需要遍历地址因此相对数组要慢， 所以判断一个集合的特点可以先判断是基于数组还是链表。</p>
<p>Collection接口下面已细化了List,Set和Queue子接口， 未什么又定义了AbstractCollection这个抽象类？具体是什么考虑？以为我发现3个接口的子类都是集成这个抽象类。 回复 三个都是Collection，总还是有共同行为的</p>
<p>可以使用priority queue ，维护两个队列 一个VIP队列 一个普通用户队列 。 当VIP队列有人的情况优先处理 回复 为什么用两个队列， PriorityQueue 不是有优先级了 PriorityQueue是非线程安全的 队列 PriorityQueue ArrayBlockingQueue ConcurrentLinkedQueue DelayQueue LinkedBlockingQueue LinkedTransferQueue PriorityBlockingQueue SynchronousQueue</p>
<p>面试的重点HashMap,实现原理，扩展什么的，1.7和1.8的区别。 还有和hashtable的异同。还有juc下面集合的熟悉程度。</p>
<p>我觉得使用queue来实现VIP业务就行了， 检查这个队列深度， 大于0时就优先先处理。 分布式环境下用MQ实现。</p>
<p>集合框架图是根据最新的jdk画的吗？ jdk1.8里List extends Collection 虚线箭头是implements ， 实线箭头是extends，按照jdk1.8，有几个画反了…</p>
<p>利用优先队列PriorityQueue或 Disruptor 可实现基于任务优先级为调度策略的执行调度系统。 Disruptor入门 http://wiki.jikexueyuan.com/project/disruptor-getting-started/ Disruptor 是一个高性能的异步处理框架，或者可以认为是最快的消息框架（轻量的 JMS）， 也可以认为是一个观察者模式的实现，或者事件监听模式的实现 java.util.concurrent.ArrayBlockingQueue 是一个非常优秀的有界队列实现。Disruptor 与之相比，性能更加的优秀。</p>
<p>SortedSet&amp;SortedMap讲解 提供了SortedMap和SortedSet接口之后可以在提供排序方案的同时， 增加更多的获取集合特定位置元素的方法 之前一直以为Verctor不属于集合，只是数组。学习了。 针对VIP客户任务优先处理场景，认为采用SortSet进行， 按照默认排序即可，数值越小优先级越高，和线程的优先级级别一致</p>
<p>和优先队列相比，不那么紧凑，例如treeset用的树比堆要多了节点开销</p>
<p>多级反馈队列 百度一下</p>
<p>为什么ArrayDeque类中的存储对象Object数组，数组的长度必须是2的n次方。</p>
<p>PriorityQueue的源码，发现其是使用最小堆结构(二叉堆)， 存放在数组中(数组索引对应树的从上到下，从左到右)。 采用上面最小，每插入一个数据， 就先与根节点比较，如果小于根节，依次换位置； 大于根节点，就放在最后一个位置。</p>
<p>TreeSet为什么不支持正序，只支持倒序(DescendingIteractor)？Tree本身支持正序列.</p>
<p>使用优先级队列，按照任务按照优先级排好序，这样优先级高的任务被优先处理。</p>

								
							</article>

					</div>
			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>