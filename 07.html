<!DOCTYPE HTML>
<html>
    <head>
        <title>java 36</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
        <link rel="stylesheet" href="assets/css/main.css" />
        <noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
    </head>
    <body class="is-preload">
            <div id="wrapper" class="fade-in">
                    <div id="intro">
                        <h1>This is<br />
                        java </h1>
                        <p>article of java  <a href="http://blankcat.github.io/">@BlankCat</a> for <a href="http://blankcat.github.io/">Home page</a><br />
                        address:<a href="http://blankcat.github.io/">http://blankcat.github.io/</a>.</p>
                        <ul class="actions">
                            <li><a href="#header" class="button icon solo fa-arrow-down scrolly">Continue</a></li>
                        </ul>
                    </div>
                    <header id="header">
                        <a href="index.html" class="logo">BlankCat</a>
                    </header>
                        <!-- Nav -->
                    <nav id="nav" style="overflow-x: scroll;">
                        <ul class="links">
                            <li class="active"><a href="index.html">01</a></li>
                            <li><a href="02.html">02</a></li>
                            <li><a href="03.html">03</a></li>
                            <li><a href="04.html">04</a></li>
                            <li><a href="05.html">05</a></li>
                            <li><a href="06.html">06</a></li>
                            <li><a href="07.html">07</a></li>
                            <li><a href="08.html">08</a></li>
                            <li><a href="09.html">09</a></li>
                            <li><a href="10.html">10</a></li>
                            <li><a href="11.html">11</a></li>
                            <li><a href="12.html">12</li>
                            <li><a href="13.html">13</a></li>
                            <li><a href="14.html">14</a></li>
                            <li><a href="15.html">15</a></li>
                            <li><a href="16.html">16</a></li>
                            <li><a href="17.html">17</a></li>
                            <li><a href="18.html">18</a></li>
                            <li><a href="19.html">19</a></li>
                            <li><a href="20.html">20</a></li>
                            <li><a href="21.html">21</a></li>
                            <li><a href="22.html">22</a></li>
                            <li><a href="23.html">23</li>
                            <li><a href="24.html">24</a></li>
                            <li><a href="25.html">25</a></li>
                            <li><a href="26.html">26</a></li>
                            <li><a href="27.html">27</a></li>
                            <li><a href="28.html">28</a></li>
                            <li><a href="29.html">29</a></li>
                            <li><a href="30.html">30</a></li>
                            <li><a href="31.html">31</a></li>
                            <li><a href="32.html">32</a></li>
                            <li><a href="33.html">33</a></li>
                            <li><a href="34.html">34</a></li>
                            <li><a href="35.html">35</a></li>
                            <li><a href="36.html">36</a></li>
                            <li><a href="37.html">37</a></li>
                            <li><a href="38.html">38</a></li>
                            <li><a href="39.html">39</a></li>
                            <li><a href="40.html">40</a></li>
                        </ul>
                        <ul class="icons">
                            <li><a href="https://github.com/BlankCat" class="icon fa-github"><span class="label">GitHub</span></a></li>
                        </ul>
                    </nav>
                    <div id="main">
                            <article class="post featured">
                                <p>08-int-integer-区别? Integer值缓存范围 从空间角度，java对象比原始数据类型开销大的多， 对象的内存结构是什么样的？对象头的结构？ 如何获取某个java对象的大小？</p>
<p>1.如何理解lambda表达式。 答：其实就是一行代码，作为参数传递。 既是一个参数，又是一组有“动作”的代码。 (f) 参数f参数类型都没有，一般的方法不都是指明参数类型的吗。 这里都没说f是File类型的，为什么会不报错呢？ 答：类型推断</p>
<p>对象由三部分组成， 【对象头，对象实例，对齐填充。】 其中对象头一般是十六个字节， 包括两部分， 第一部分有哈希码，锁状态标志，线程持有的锁，偏向线程id，gc分代年龄等。 第二部分是类型指针，也就是对象指向它的类元数据指针，可以理解，对象指向它的类。</p>
<pre><code>对象实例
    就是对象存储的真正有效信息，
    也是程序中定义各种类型的字段包括父类继承的和子类定义的，
    这部分的存储顺序会被虚拟机和代码中定义的顺序影响
    （这里问一下，这个被虚拟机影响是不是就是重排序？？如果是的话，
    我知道的volatile定义的变量不会被重排序应该就是这里不会受虚拟机影响吧？？）。

第三部分对齐填充只是一个类似占位符的作用，因为内存的使用都会被填充为八字节的倍数。</code></pre>
<p>节选自《深入理解JAVA虚拟机》： 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域： 对象头（Header）、 实例数据（Instance Data）和 对齐填充（Padding）。 1对象头 HotSpot虚拟机的对象头包括两部分信息， 第一部分用于存储【对象自身的运行时数据】， 如哈希码（HashCode）、 GC分代年龄、 锁状态标志、 线程持有的锁、 偏向线程ID、 偏向时间戳等， 这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“Mark Word”。</p>
<pre><code>    对象头的另外一部分是类型指针，即对象【指向它的类元数据的指针】，
    虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，
    换句话说，查找对象的元数据信息并不一定要经过对象本身，这点将在2.3.3节讨论。
    另外，
    如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，
    因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。

2实例数据
    接下来的【实例数据部分】是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。
    无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。

3对齐填充
    第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。</code></pre>
<p>1 int和Integer JDK1.5引入了自动装箱与自动拆箱功能， Java可根据上下文，实现int/Integer,double/Double,boolean/Boolean等基本类型与相应对象之间的自动转换， 为开发过程带来极大便利。</p>
<p>最常用的是通过new方法构建Integer对象。但是，基于大部分数据操作都是集中在有限的、较小的数值范围， 在JDK1.5 中新增了【静态工厂方法 valueOf】，其背后实现是将int值为-128 到 127 之间的Integer对象进行缓存， 在调用时候直接从缓存中获取，进而提升构建对象的性能，也就是说使用该方法后， 如果两个对象的int值相同且落在缓存值范围内，那么这个两个对象就是同一个对象； 当值较小且频繁使用时，推荐优先使用整型池方法（时间与空间性能俱佳）。</p>
<p>2 注意事项【1取值范围2拆箱装箱影响性能3线程安全】 [1] 基本类型均具有取值范围，在大数<em>大数的时候，有可能会出现越界的情况。 [2] 基本类型转换时，使用声明的方式。例：long result= 1234567890 </em> 24 * 365； 结果值一定不会是你所期望的那个值，因为1234567890 * 24已经超过了int的范围， 如果修改为：long result= 1234567890L * 24 * 365；就正常了。 [3] 慎用基本类型处理货币存储。如采用double常会带来差距， 常采用BigDecimal、整型（如果要精确表示分，可将值扩大100倍转化为整型）解决该问题。 [4] 优先使用基本类型。原则上，建议避免无意中的装箱、拆箱行为，尤其是在性能敏感的场合， [5] 如果有线程安全的计算需要，建议考虑使用类型AtomicInteger、AtomicLong 这样的线程安全类。 部分比较宽的基本数据类型，比如 float、double，甚至不能保证更新操作的原子性， 可能出现程序读取到只更新了一半数据位的数值。</p>
<p>原始数据类型和 Java 泛型并不能配合使用， 也就是 Primitive Types（原始类型） 和 Generic（泛型 ） 不能混用， 于是JAVA就设计了这个auto-boxing/unboxing机制， 实际上就是primitive value 与 object之间的隐式转换机制，否则要是没有这个机制， 开发者就必须每次手动显示转换，那多麻烦是不是？ 但是primitive value 与 object各自有各自的优势，primitive value在内存中存的是值， 所以找到primitive value的内存位置，就可以获得值； 不像object存的是reference，找到object的内存位置，还要根据reference找下一个内存空间，要产生更多的IO， 所以计算性能比primitive value差， 但是object具备generic的能力，更抽象，解决业务问题编程效率高。 于是JAVA设计者的初衷估计是这样的： 如果开发者要做计算，就应该使用primitive value如果开发者要处理业务问题，就应该使用object，采用Generic机制； 反正JAVA有auto-boxing/unboxing机制，对开发者来讲也不需要注意什么。然后为了弥补object计算能力的不足， 还设计了static valueOf()方法提供缓存机制，算是一个弥补。</p>
<p></p>
<ol type="1">
<li>Mark Word:标记位 4字节，类似轻量级锁标记位，偏向锁标记位等。</li>
<li>Class对象指针:4字节，指向对象对应class对象的内存地址。</li>
<li>对象实际数据:对象所有成员变量。</li>
<li>对齐:对齐填充字节，按照8个字节填充。 Integer占用内存大小，4+4+4+4=16字节。 回复 不错，如果是64位不用压缩指针，对象头会变大，还可能有对齐开销</li>
</ol>
<p>计算对象大小可通过dump内存之后用memory analyze分析 回复 嗯，也可以利用： jol， jmap，或者instrument api（Java agent）等等</p>
<p>如果使用原始类型int定义一个变量在-128和127之间，如int c = 64; 会放入Integer 常量缓存吗(IntegerCache)？编译器是怎么操作的？ 回复 不需要，不是对象</p>
<p>java内存结构 对象头： markword：用于存储对象自身的运行时数据， 如哈希码、GC分代年龄、锁状态标志、线程持有的锁等。 这部分数据长度在32位机器和64位机器虚拟机中分别为4字节和8字节； lass指针：即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象属于哪个类的实例； length：如果是java数组，对象头必须有一块用于记录数组长度的数据，用4个字节来int来记录数组长度； 实例数据 实例数据是对象真正存储的有效信息， 也是程序代码中定义的各种类型的字段内容。 无论是从父类继承下来还是在子类中定义的数据， 都需要记录下来 堆积填充 对于hotspot迅疾的自动内存管理系统要求对象的起始地址必须为8字节的整数倍， 这就要求当部位8字节的整数倍时，就需要填充数据对其填充。 原因是访问未对齐的内存，处理器需要做两次内存访问，而对齐的内存访问仅需一次访问</p>
<p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域： 对象头（Header）、 实例数据（Instance Data）和 对齐填充（Padding）。</p>
<p>HotSpot虚拟机的 对象头包括两部分信息， 第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、 GC分代年龄、 锁状态标志、 线程持有的锁、 偏向线程ID、 偏向时间戳等， 这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“Mark Word”。</p>
<pre><code>对象头的另外一部分是类型指针，
    即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
    并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，
    查找对象的元数据信息并不一定要经过对象本身，这点将在2.3.3节讨论。另外，
    如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，
    因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，
    但是从数组的元数据中却无法确定数组的大小。</code></pre>
<p>接下来的实例数据部分是对象真正存储的有效信息， 也是在程序代码中所定义的各种类型的字段内容。 无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。</p>
<p>第三部分对齐填充并不是必然存在的， 也没有特别的含义，它仅仅【起着占位符的作用】。 由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍， 换句话说，就是对象的大小必须是8字节的整数倍。</p>
<p>JAVA的内存结构分为3部分： 1，对象头 有两部分, markWord和 Class对象指针， markwork包括存储对象自身的运行时数据， 如哈希码（HashCode）、 GC分代年龄、 锁状态标志、 线程持有的锁、 偏向线程ID、 偏向时间戳， 2，实例数据 3，对齐填充</p>
<p>打印一个对象的大小？ 获取一个JAVA对象的大小，可以将一个对象进行序列化为二进制的Byte，便可以查看大小， Integer value = 10; ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(value); // // 读出当前对象的二进制流信息 System.out.println(bos.size());</p>
<p>long的赋值也不是原子操作吗？</p>
<p>原始数据类型的包装类是对象吗？ 回复 类是类，实例化后才是对象</p>
<p>反编译输出怎么理解的，看不懂语法 回复 具体哪一段，是文章中片段的invokestatic之类吗？ 如果是的话，最准确的可以参考java虚拟机规范， 查询相应之类；大多数情况下可以搜索相关分析文章，理解难道会小些</p>
<p>integer获取环境变量数值的方法，这个具体是指哪个方法？ 回复 getInteger，建议看看文档</p>

                                
                            </article>

                    </div>
            </div>

        <!-- Scripts -->
            <script src="assets/js/jquery.min.js"></script>
            <script src="assets/js/jquery.scrollex.min.js"></script>
            <script src="assets/js/jquery.scrolly.min.js"></script>
            <script src="assets/js/browser.min.js"></script>
            <script src="assets/js/breakpoints.min.js"></script>
            <script src="assets/js/util.js"></script>
            <script src="assets/js/main.js"></script>

    </body>
</html>