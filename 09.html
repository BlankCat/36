<!DOCTYPE HTML>
<html>
	<head>
		<title>java 36</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">
			<div id="wrapper" class="fade-in">
					<div id="intro">
						<h1>This is<br />
						java </h1>
						<p>article of java  <a href="http://blankcat.github.io/">@BlankCat</a> for <a href="http://blankcat.github.io/">Home page</a><br />
						address:<a href="http://blankcat.github.io/">http://blankcat.github.io/</a>.</p>
						<ul class="actions">
							<li><a href="#header" class="button icon solo fa-arrow-down scrolly">Continue</a></li>
						</ul>
					</div>
					<header id="header">
						<a href="index.html" class="logo">BlankCat</a>
					</header>
						<!-- Nav -->
					<nav id="nav" style="overflow-x: scroll;">
						<ul class="links">
							<li class="active"><a href="index.html">01</a></li>
							<li><a href="02.html">02</a></li>
							<li><a href="03.html">03</a></li>
							<li><a href="04.html">04</a></li>
							<li><a href="05.html">05</a></li>
							<li><a href="06.html">06</a></li>
							<li><a href="07.html">07</a></li>
							<li><a href="08.html">08</a></li>
							<li><a href="09.html">09</a></li>
							<li><a href="10.html">10</a></li>
							<li><a href="11.html">11</a></li>
							<li><a href="12.html">12</li>
							<li><a href="13.html">13</a></li>
							<li><a href="14.html">14</a></li>
							<li><a href="15.html">15</a></li>
							<li><a href="16.html">16</a></li>
							<li><a href="17.html">17</a></li>
							<li><a href="18.html">18</a></li>
							<li><a href="19.html">19</a></li>
							<li><a href="20.html">20</a></li>
							<li><a href="21.html">21</a></li>
							<li><a href="22.html">22</a></li>
							<li><a href="23.html">23</li>
							<li><a href="24.html">24</a></li>
							<li><a href="25.html">25</a></li>
							<li><a href="26.html">26</a></li>
							<li><a href="27.html">27</a></li>
							<li><a href="28.html">28</a></li>
							<li><a href="29.html">29</a></li>
							<li><a href="30.html">30</a></li>
							<li><a href="31.html">31</a></li>
							<li><a href="32.html">32</a></li>
							<li><a href="33.html">33</a></li>
							<li><a href="34.html">34</a></li>
							<li><a href="35.html">35</a></li>
							<li><a href="36.html">36</a></li>
							<li><a href="37.html">37</a></li>
							<li><a href="38.html">38</a></li>
							<li><a href="39.html">39</a></li>
							<li><a href="40.html">40</a></li>
						</ul>
						<ul class="icons">
							<li><a href="https://github.com/BlankCat" class="icon fa-github"><span class="label">GitHub</span></a></li>
						</ul>
					</nav>
					<div id="main">
							<article class="post featured">
								<p>09-hashtable-hashmap-treemap-区别 解决hash冲突的方案有那些？</p>
<p>解决哈希冲突的常用方法有： 开放定址法 基本思想是： 当关键字key的哈希地址p=H（key）【计算hash值】出现冲突时，以冲突的哪个位置开始以p为基础， 产生另一个哈希地址p1， 如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…， 直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。</p>
<p>再哈希法 这种方法是同时构造多个不同的哈希函数： Hi=RH1（key）【重复re hash】 i=1，2，…，k 当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。 这种方法不易产生聚集，但增加了计算时间。</p>
<p>链地址法 这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表， 并将单链表的头指针存在哈希表的第i个单元中， 因而查找、插入和删除主要在同义词链中进行。 链地址法适用于经常进行插入和删除的情况。 (32、40、36、53、16、46、71、27、42、24、49、64)哈希表长度为13， 哈希函数为H(key)=key%13,则链表法结果如下： 0<br />
1 -&gt; 40 -&gt; 27 -&gt; 53 2 3 -&gt; 16 -&gt; 42 4 5 6 -&gt; 32 -&gt; 71 7 -&gt; 46 8 9 10 -&gt; 36 -&gt; 49 11 -&gt; 24 12 -&gt; 64</p>
<p>建立公共溢出区 这种方法的基本思想是：将哈希表分为基本表和溢出表两部分， 凡是和基本表发生冲突的元素，一律填入溢出表。</p>
<p>最常用的方法就是 线性再散列。 即插入元素时，没有发生冲突放在原有的规则下的空槽下， 发生冲突时， 简单遍历hash表，找到表中下一个空槽，进行元素插入。 查找元素时，找到相应的位置的元素，如果不匹配则进行遍历hash表。</p>
<p>然后就是我们非线性再散列， 就是冲突时，再hash，核心思想是， 如果产生冲突，产生一个新的hash值进行寻址， 如果还是冲突，则继续。 上述的方法，主要的缺点在于不能从表中删除元素。 还有就是我们hashmap的思想外部拉链。</p>
<p>Hashtable、HashMap、TreeMap心得【实现map接口，k-v存储，一个key对应一个value】 三者均实现了Map接口， 存储的内容是基于key-value的键值对映射， 一个映射不能有重复的键，一个键最多只能映射一个值。</p>
<p>（1）元素特性 HashTable中的key、value都不能为null； HashMap中的key、value可以为null，很显然只能有一个key为null的键值对，但是允许有多个值为null的键值对； TreeMap中当未实现 Comparator 接口时，key 不可以为null； 当实现 Comparator 接口时，若未对null情况进行判断，则key不可以为null，反之亦然。</p>
<p>（2）顺序特性 HashTable、HashMap具有无序特性。 TreeMap是利用红黑树来实现的（树中的每个节点的值，都会大于或等于它的左子树种的所有节点的值，并且小于或等于它的右子树中的所有节点的值）， 实现了SortMap接口，能够对保存的记录根据键进行排序。所以一般需要排序的情况下是选择TreeMap来进行， 默认为升序排序方式（深度优先搜索），可自定义实现Comparator接口实现排序方式。</p>
<p>（3）初始化与增长方式 初始化时： HashTable在不指定容量的情况下的默认容量为11， 且不要求底层数组的容量一定要为2的整数次幂； HashMap默认容量为16，且要求容量一定为2的整数次幂。</p>
<pre><code>扩容时：
    Hashtable将容量变为原来的2倍加1；
    HashMap扩容将容量变为原来的2倍。</code></pre>
<p>（4）线程安全性 HashTable其方法函数都是同步的（采用synchronized修饰）， 不会出现两个线程同时对数据进行操作的情况，因此保证了线程安全性。 也正因为如此，在多线程运行环境下效率表现非常低下。 因为当一个线程访问HashTable的同步方法时，其他线程也访问同步方法就会进入阻塞状态。 比如当一个线程在添加数据时候，另外一个线程即使执行获取其他数据的操作也必须被阻塞， 大大降低了程序的运行效率，在新版本中已被废弃，不推荐使用。</p>
<pre><code>HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。
如果需要同步
（1）可以用 Collections的synchronizedMap方法；
（2）使用ConcurrentHashMap类，相较于HashTable锁住的是对象整体，
     ConcurrentHashMap基于lock实现锁分段技术。
     首先将Map存放的数据分成一段一段的存储方式，然后给每一段数据分配一把锁，
     当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。
     ConcurrentHashMap不仅保证了多线程运行环境下的数据访问安全性，而且性能上有长足的提升。</code></pre>
<p>(5)一段话HashMap HashMap基于哈希思想，实现对数据的读写。 当我们将键值对传递给put()方法时， 它调用键对象的hashCode()方法来计算hashcode， 让后找到bucket位置【桶数据桶，装数据】来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。 HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。当两个不同的键对象的hashcode相同时， 它们会储存在同一个bucket位置的链表中，可通过键对象的equals()方法用来找到键值对。 如果链表大小超过阈值（TREEIFY_THRESHOLD, 8），链表就会被改造为树形结构。</p>
<p>什么时候也能讲讲红黑树的树化具体过程，那个旋转一直没搞懂。 另外treeifyBin这个单词的词面意思是什么？</p>
<p>如果hashmap中不存在hash冲突 是不是就相当于一个数组结构呢 就不存在链表了呢</p>
<p>针对负载因子，您所指的存太满会影响性能是指什么？毕竟已经开辟了相应内存空间的，没什么不用呢？ 2018-05-24  作者回复 冲突可能会增加,影响查询之类性能，当然看具体的需求 2018-05-25</p>
<p>情梦阿里   当链表长度达到阙值时，【容量】大于MIN_TREEIFY_CAPACITY会触发树化改造，我有两个疑问， 1.【容量】是指单个桶的链表长度还是指元素数量，或者是指hashmap的initialCapacity呢？ 2.MIN_TREEIFY_CAPACITY这个值是固定的还是计算出来的，如果是固定的是多少啊？如果是计算得来的，是如何计算得呢？</p>
<p></p>
<p>为什么不是一开始就树化，而是要等到一定程度再树化，链表一开始就是消耗查找性能啊？ 另外其实不太明白为什么是0.75的负载因子，如果是.08或者0.9会有什么影响吗？毕竟已经开辟了相关内存空间 回复 数据少的时候，平均访问长度很小，没必要麻烦； 0.75是通用场景建议，取个平衡，具体看你调整它目标是什么了</p>
<p>我一直认为：JAVA集合类是非常好的学习材料。 如果敢说精通JAVA集合类，计算机功底肯定不会太差</p>
<p>equals 的对称、反射、传递等特性。 这里的反射是不是写错了，应该是自反性，对称性，传递性，一致性等等</p>
<p>我感觉树化一个目的是防止hash冲突导致的resize时的死循环， 还有就是减少查找遍历路径，毕竟树的查找不用遍历全部， 特别像是平衡二叉树的遍历。 回复 是的，树性能恶化不会太剧烈</p>

								
							</article>

					</div>
			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>