<!DOCTYPE HTML>
<html>
    <head>
        <title>java 36</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
        <link rel="stylesheet" href="assets/css/main.css" />
        <noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
    </head>
    <body class="is-preload">
            <div id="wrapper" class="fade-in">
                    <div id="intro">
                        <h1>This is<br />
                        java </h1>
                        <p>article of java  <a href="http://blankcat.github.io/">@BlankCat</a> for <a href="http://blankcat.github.io/">Home page</a><br />
                        address:<a href="http://blankcat.github.io/">http://blankcat.github.io/</a>.</p>
                        <ul class="actions">
                            <li><a href="#header" class="button icon solo fa-arrow-down scrolly">Continue</a></li>
                        </ul>
                    </div>
                    <header id="header">
                        <a href="index.html" class="logo">BlankCat</a>
                    </header>
                        <!-- Nav -->
                    <nav id="nav" style="overflow-x: scroll;">
                        <ul class="links">
                            <li class="active"><a href="index.html">01</a></li>
                            <li><a href="02.html">02</a></li>
                            <li><a href="03.html">03</a></li>
                            <li><a href="04.html">04</a></li>
                            <li><a href="05.html">05</a></li>
                            <li><a href="06.html">06</a></li>
                            <li><a href="07.html">07</a></li>
                            <li><a href="08.html">08</a></li>
                            <li><a href="09.html">09</a></li>
                            <li><a href="10.html">10</a></li>
                            <li><a href="11.html">11</a></li>
                            <li><a href="12.html">12</li>
                            <li><a href="13.html">13</a></li>
                            <li><a href="14.html">14</a></li>
                            <li><a href="15.html">15</a></li>
                            <li><a href="16.html">16</a></li>
                            <li><a href="17.html">17</a></li>
                            <li><a href="18.html">18</a></li>
                            <li><a href="19.html">19</a></li>
                            <li><a href="20.html">20</a></li>
                            <li><a href="21.html">21</a></li>
                            <li><a href="22.html">22</a></li>
                            <li><a href="23.html">23</li>
                            <li><a href="24.html">24</a></li>
                            <li><a href="25.html">25</a></li>
                            <li><a href="26.html">26</a></li>
                            <li><a href="27.html">27</a></li>
                            <li><a href="28.html">28</a></li>
                            <li><a href="29.html">29</a></li>
                            <li><a href="30.html">30</a></li>
                            <li><a href="31.html">31</a></li>
                            <li><a href="32.html">32</a></li>
                            <li><a href="33.html">33</a></li>
                            <li><a href="34.html">34</a></li>
                            <li><a href="35.html">35</a></li>
                            <li><a href="36.html">36</a></li>
                            <li><a href="37.html">37</a></li>
                            <li><a href="38.html">38</a></li>
                            <li><a href="39.html">39</a></li>
                            <li><a href="40.html">40</a></li>
                        </ul>
                        <ul class="icons">
                            <li><a href="https://github.com/BlankCat" class="icon fa-github"><span class="label">GitHub</span></a></li>
                        </ul>
                    </nav>
                    <div id="main">
                            <article class="post featured">
                                <p>20-java并发包-concurrentLinkedQueue-LinkedBlockQueue区别 用栈实现blockqueue实现思路</p>
<p>jdk7并发包 外层框架主要有 Lock(ReentrantLock【可重入锁】、 ReadWriteLock【读写锁】等)、 同步器（semaphores等）、 阻塞队列（BlockingQueue等）、 Executor（线程池）、 并发容器（ConcurrentHashMap等）、 还有Fork/Join框架； 内层有 AQS（AbstractQueuedSynchronizer类，锁功能都由他实现）、 非阻塞数据结构、 原子变量类(AtomicInteger等无锁线程安全类)三种。 底层就实现是 volatile和CAS</p>
<p>list hashmap==table list HashEntry（hash entry数组） == sigment【特殊的hash table 】 sigment 数组构成hashtable</p>
<p>能够理解 ConcurrentLinkedDeque 和 LinkedBlockingQueue 的主要功能区别。 这段应该是 “ConcurrentLinkedDeque 和 LinkedBlockingDeque 的主要功能区别”</p>
<p>实现课后题过程中把握以下几个维度， 1，数据操作的锁粒度。 2，计数，遍历方式。 3，数据结构空，满时线程的等待方式，有锁或无锁方式。 4，使用离散还是连续的存储结构。</p>
<p>用栈实现BlockingQueue，我的理解是： 栈是LIFO，BlockingQueue是FIFO，因此需要两个栈。 take时先把栈A全部入栈到栈B， 然后栈B出栈得到目标元素； put时把栈B全部入栈到栈A， 然后栈A再入栈目标元素。相当于倒序一下。</p>
<p>https://www.cnblogs.com/java-zhao/category/776210.html 《分布式Java应用：基础与实践》，林昊 著</p>
<p>1、常用的并发集合类 ConcurrentHashMap：线程安全的HashMap的实现 CopyOnWriteArrayList：线程安全且在读操作时无锁的ArrayList CopyOnWriteArraySet：基于CopyOnWriteArrayList，不添加重复元素 ArrayBlockingQueue：基于数组、先进先出、线程安全，可实现指定时间的阻塞读写，并且容量可以限制 LinkedBlockingQueue：基于链表实现，读写各用一把锁，在高并发读写操作都多的情况下，性能优于ArrayBlockingQueue 2、原子类 AtomicInteger：线程安全的Integer，基于CAS（无阻塞，CPU原语），优于使用同步锁的Integer 3、线程池 ThreadPoolExecutor：一个高效的支持并发的线程池， 可以很容易的讲一个实现了Runnable接口的任务放入线程池执行，但要用好这个线程池， 必须合理配置corePoolSize、最大线程数、任务缓冲队列，以及队列满了+线程池满时的回绝策略， 一般而言对于这些参数的配置，需考虑两类需求：高性能和缓冲执行。 Executor：提供了一些方便的创建ThreadPoolExecutor的方法。 FutureTask：可用于异步获取执行结果或取消执行任务的场景，基于CAS，避免锁的使用 4、锁 ReentrantLock：与synchronized效果一致， 但是又更加灵活，支持公平/非公平锁、支持可中断的锁、 支持非阻塞的tryLock(可超时)、支持锁条件等， 需要手工释放锁，基于AbstractQueueSynchronizer ReentrantReadWriteLock： 与ReentrantLock没有关系，采用两把锁，用于读多写少的情形</p>
<p>注：在本系列的博客中，对以上的类会着重从以下几个方面去记录： 用法 源码解读 使用场景 一些必要的比较</p>
<p>ConcurrentHashMap 1、对于ConcurrentHashMap需要掌握以下几点 Map的创建：ConcurrentHashMap() 往Map中添加键值对：即put(Object key, Object value)方法 获取Map中的单个对象：即get(Object key)方法 删除Map中的对象：即remove(Object key)方法 判断对象是否存在于Map中：containsKey(Object key) 遍历Map中的对象：即keySet().iterator()，在实际中更常用的是增强型的for循环去做遍历 总结： 数据结构： 一个指定个数的Segment数组， 数组中的每一个元素Segment相当于一个HashTable 加锁情况（分段锁）： put get中找到了hash与key都与指定参数相同的HashEntry， 但是value==null的情况 remove size()：三次尝试后，还未成功， 遍历所有Segment，分别加锁（即建立全局锁）</p>
<p>CopyOnWriteArrayList 1、对于CopyOnWriteArrayList需要掌握以下几点 创建：CopyOnWriteArrayList() 添加元素：即add(E)方法 获取单个对象：即get(int)方法 删除对象：即remove(E)方法 遍历所有对象：即iterator()，在实际中更常用的是增强型的for循环去做遍历 注：CopyOnWriteArrayList是一个线程安全，读操作时无锁的ArrayList。</p>
<pre><code>总结：
    线程安全，读操作时无锁的ArrayList
    底层数据结构是一个Object[]，
        初始容量为0，之后每增加一个元素，容量+1，数组复制一遍
    增删改上锁、读不上锁
    遍历过程由于遍历的只是全局数组的一个副本，
        即使全局数组发生了增删改变化，副本也不会变化，所以不会发生并发异常
    读多写少且脏数据影响不大的并发情况下，选择CopyOnWriteArrayList
疑问：
每增加一个新元素，都要进行一次数组的复制消耗，
    那为什么每次不将数组的元素设大（比如说像ArrayList那样，设置为原来的1.5倍+1），
    这样就会大大减少因为数组元素复制所带来的消耗？
get(int)操作会发生脏读，为什么？</code></pre>
<p>CopyOnWriteArraySet 对于CopyOnWriteArraySet需要掌握以下几点 创建：CopyOnWriteArraySet() 添加元素：即add(E)方法 删除对象：即remove(E)方法 遍历所有对象：即iterator()，在实际中更常用的是增强型的for循环去做遍历 总结： CopyOnWriteArraySet 底层就是一个CopyOnWriteArrayList CopyOnWriteArraySet在add元素的时候要遍历一遍数组， 从而起到不添加重复元素的作用，但是由于要遍历数组， 效率也会低于CopyOnWriteArrayList的add Set集合没有按索引直接获取或修改或添加或删除的方法 （eg.get(int index),add(int index,E e),set(int index,E e),remove(int index)）</p>
<p>附1 Java内存模型与共享变量可见性 1、Java内存模型（JMM） Java内存模型的主要目标： 定义在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。 注意：上边的变量指的是共享变量（实例字段、静态字段、数组对象元素）， 不包括线程私有变量（局部变量、方法参数），因为私有变量不会存在竞争关系。</p>
<p>说明： 所有共享变量存于主内存【堆内存】 每一条线程都有自己的工作内存（就是上图所说的本地内存） 工作内存中保存了被该线程使用到的变量的主内存副本 注意： 线程对变量的操作都要在工作内存中进行，不能直接操作主内存 不同的线程之间无法直接访问对方的工作内存中的变量 不同线程之间的变量的传递必须通过主内存 类比：（注意：主内存与工作内存只是一个概念，与堆栈内存没有关系，下边的类比只是帮助理解）</p>
<p>主内存： 对应于Java堆中的对象实例数据部分 （注意：堆中还保存了对象的其他信息，eg.Mark Word、Klass Point和用于字节对其补白的填充数据） 工作内存： 对应于栈中的部分区域,线程读立的内存区域</p>
<p>1.2、8条内存屏障指令： 下面只列出6条与之后内容相关的，其余的查看《深入理解Java虚拟机》 lock：作用于主内存，把一个变量标识为一条线程独占的状态 unlock：作用于主内存，把一个处于锁定的变量解锁 下边四条是与volatile实现内存可见性直接相关的四条（store、write、read、load） store：把工作内存中的变量的值传送到主内存中 write：把store操作从工作内存中得到的变量值放入到主内存的变量中 read：把一个变量的值从主内存中传输到线程的工作内存 load：把read操作从主内存中获取到的变量值放入工作内存的变量中去 注意： 一个变量在同一时刻只允许一条线程对其进行lock操作 lock操作会将该变量在所有线程工作内存中的变量副本清空，否则就起不到锁的作用了 lock操作可被同一条线程多次进行，lock几次，就要unlock几次（可重入锁） unlock之前必须先执行store-write store-write必须成对出现（工作内存–&gt;主内存） read-load必须成对出现（主内存–&gt;工作内存）</p>
<p>2、变量对所有线程的可见性 可见性：线程1对共享变量的修改能及时被线程2看到</p>
<p>2.1、共享变量不可见的原因 共享变量更新后的值没有在工作内存和主内存之间及时更新 线程交错执行 指令重排序结合线程交错执行 2.2、实现共享变量及时更新的措施 线程1修改过共享变量后，将共享变量刷到主内存，然后，线程2从主内存读取该共享变量，将该共享变量载入到工作内存中 注意： 在短时间内的高并发情况下，如果发生下列三种情况，则线程2就读不到线程1修改过的最新的值了， 可能线程1根本来不及将修改过后的共享变量刷到主内存（这个时间非常短，但是还是有）的时候， 线程2就已经读取了原有的主内存变量到其工作内存中。 可能线程1虽然将修改过后的值刷到了主内存中， 但是线程2的工作内存中的变量副本还没来得及从CPU刷新回来， 所以线程2读取到的还是原来的工作内存中的变量副本 可能线程1根本来不及将修改过后的共享变量刷到主内存的时候，同时， 线程2的工作内存中的变量副本还没来得及从CPU刷新回来 注意： 工作内存中的变量副本在使用之后，不会立刻消失掉，会一直存在， 这样其值也一直不变，直到对其进行写操作或数据从CPU中刷新回来（类比volatile-read的作用）。</p>
<p>2.3、指令重排序： 代码书写顺序与实际执行顺序不同（编译器或处理器为提高程序性能做的优化）</p>
<p>volatile 2、具体的实现原理</p>
<pre><code>        对volatile变量执行写操作时，会在写操作后加入一条store屏障指令
        对volatile变量执行读操作时，会在读操作前加入一条load屏障指令
    说人话：
        对volatile变量执行读操作时，都要强制的先从主内存读取最新的变量值到工作内存，然后再读工作内存中所存储的变量副本
        对volatile变量执行写操作时，又会强制的将工作内存中的刚刚改变的值写到主内存中去
        通过上边这样模式，每个线程拿到的volatile变量值都是最新的。
    注意：
        volatile无法实现原子性：
        1）线程a获取了count==0；
        2）线程b获取了count==0；
        3）线程b对count+1，之后写入主内存count==1；
        4）线程a对count+1，之后写入主内存count==1；
        结果count==1而非count==2，原因就是线程a获取count后，
        volatile不能实现原子性，这个时候b也能去操作count。
        想要实现原子性，使用synchronized去锁住增加方法，
        或者使用ReentrantLock去锁住增加代码；当然，
        以上场景使用AtomicInteger更好。

    · 使用关键字volatile，
        当一个变量被volatile关键字修饰时，
        对于共享资源的读操作会直接在主内存中进行
        （当然也会缓存到工作内存中，当其他线程对该共享资源进行了修改，
        则会导致当前线程在工作内存中的共享资源失效，所以必须从主内存中再次获取），
        对于共享资源的写操作当然是先要修改工作内存，
        但是修改结束后会立刻将其刷新到主内存中。
    · 通过synchronized关键字能够保证可见性，
        synchronized关键字能够保证同一时刻只有一个线程获得锁，
        然后执行同步方法，并且还会确保在锁释放之前，
        会将对变量的修改刷新到主内存当中。
    · 通过JUC提供的显式锁Lock也能够保证可见性，
        Lock的lock方法能够保证在同一时 刻只有一个线程获得锁然后执行同步方法，
        并且会确保在锁释放（Lock的unlock方法）之前会将对变量的修改刷新到主内存当中。


    什么是指令重排序？有两个层面：
        在虚拟机层面，
            为了尽可能减少内存操作速度远慢于CPU运行速度所带来的CPU空置的影响，
            虚拟机会按照自己的一些规则(这规则后面再叙述)将程序编写顺序打乱——即写在后面的代码在时间顺序上可能会先执行，
            而写在前面的代码会后执行——以尽可能充分地利用CPU。

        在硬件层面，
            CPU会将接收到的一批指令按照其规则重排序，
            同样是基于CPU速度比缓存速度快的原因，
            和上一点的目的类似，只是硬件处理的话，每次只能在接收到的有限指令范围内重排序，
            而虚拟机可以在更大层面、更多指令范围内重排序。硬件的重排序机制参见
            《从JVM并发看CPU内存指令重排序(Memory Reordering)》
    3、volatile使用场景
        1运算结果并不依赖当前值，例如Boolean就可，而number++这样的就不行，这样的情况使用锁
        2运算结果依赖当前值但是能够确保只有单一线程修改变量的值，例如ConcurrentHashMap中Segment的count变量
        count变量只能由单一线程来改变（因为put和remove都是加锁的），但是修改后未必能及时刷新到主内存；这时候读线程去读取的话就可能读到旧数据。所以需要volatile来保证可见性。
        3变量不需要与其他的状态变量共同参与不变约束，例如low&lt;up这样的场景就不行
        4在访问变量时需要使用锁，就不要使用volatile（《java并发编程实战》）
        所以说，volatile只能实现部分线程安全（实际上只能实现可见性）。 如果volatile用得好的话，比synchronized强不少，因为不需要上下文切换。

    注：
        关于volatile禁止指令重排序的介绍去看《深入理解Java虚拟机（第二版）》第十二章&quot;Java内存模型与线程&quot;
        通常情况下，能用volatile解决的就不去用synchronized了</code></pre>
<p>1、对于ReentrantLock需要掌握以下几点 ReentrantLock的创建（公平锁/非公平锁） 上锁：lock() 解锁：unlock() 首先说一下类结构： ReentrantLock–&gt;Lock NonfairSync/FairSync–&gt;Sync–&gt;AbstractQueuedSynchronizer–&gt;AbstractOwnableSynchronizer NonfairSync/FairSync–&gt;Sync是ReentrantLock的三个内部类 Node是AbstractQueuedSynchronizer的内部类 注意：上边这四条线，对应关系：“子类”–&gt;“父类”</p>
<pre><code>2、ReentrantLock的创建
    支持公平锁（先进来的线程先执行）
    支持非公平锁（后进来的线程也可能先执行）
    非公平锁与非公平锁的创建

非公平锁：ReentrantLock()或ReentrantLock(false)
    final ReentrantLock lock = new ReentrantLock();
公平锁：ReentrantLock(true)
    final ReentrantLock lock = new ReentrantLock(true)

总结：公平锁与非公平锁对比
    FairSync：lock()少了插队部分
            （即少了CAS尝试将state从0设为1，进而获得锁的过程）
    FairSync：tryAcquire(int acquires)多了需要判断当前线程是否在等待队列首部的逻辑
            （实际上就是少了再次插队的过程，但是CAS获取还是有的）。
    最后说一句，
    ReentrantLock是基于AbstractQueuedSynchronizer实现的，
            AbstractQueuedSynchronizer可以实现独占锁也可以实现共享锁，
            ReentrantLock只是使用了其中的独占锁模式</code></pre>
<p>ArrayBlockingQueue 1、对于ArrayBlockingQueue需要掌握以下几点 创建 入队（添加元素） 出队（删除元素） 2、创建 public ArrayBlockingQueue(int capacity, boolean fair) public ArrayBlockingQueue(int capacity) 使用方法： Queue<String> abq = new ArrayBlockingQueue<String>(2); Queue<String> abq = new ArrayBlockingQueue<String>(2,true); 通过使用方法，可以看出ArrayBlockingQueue支持ReentrantLock的公平锁模式与非公平锁模式，对于这两种模式</p>
<pre><code>3、入队
    3.1、public boolean offer(E e)
    原理：
    在队尾插入一个元素， 如果队列没满，立即返回true； 如果队列满了，立即返回false
4、出队
    4.1、public E poll()
    原理：
        如果没有元素，直接返回null；如果有元素，将队头元素置null，但是要注意队头是随时变化的，并非一直是items[0]。
    使用方法：
        abq.poll();

2、三种入队对比：
    offer(E e)：如果队列没满，立即返回true； 如果队列满了，立即返回false--&gt;不阻塞
    put(E e)：如果队列满了，一直阻塞，直到数组不满了或者线程被中断--&gt;阻塞
    offer(E e, long timeout, TimeUnit unit)：在队尾插入一个元素,，如果数组已满，则进入等待，直到出现以下三种情况：--&gt;阻塞
    被唤醒
    等待时间超时
    当前线程被中断
     

3、三种出对对比：
    poll()：如果没有元素，直接返回null；如果有元素，出队
    take()：如果队列空了，一直阻塞，直到数组不为空或者线程被中断--&gt;阻塞
    poll(long timeout, TimeUnit unit)：如果数组不空，出队；如果数组已空且已经超时，返回null；
    如果数组已空且时间未超时，则进入等待，直到出现以下三种情况：
    被唤醒
    等待时间超时
    当前线程被中断</code></pre>
<p>1、对于LinkedBlockingQueue需要掌握以下几点 创建 入队（添加元素） 出队（删除元素） 2、创建 Node节点内部类与LinkedBlockingQueue的一些属性 注意点： LinkedBlockingQueue的组成一个链表+两把锁+两个条件 2、三种入队对比： offer(E e)：如果队列没满，立即返回true； 如果队列满了，立即返回false–&gt;不阻塞 put(E e)：如果队列满了，一直阻塞，直到队列不满了或者线程被中断–&gt;阻塞 offer(E e, long timeout, TimeUnit unit)：在队尾插入一个元素,，如果队列已满，则进入等待，直到出现以下三种情况：–&gt;阻塞 被唤醒 等待时间超时 当前线程被中断</p>
<p>3、三种出队对比： poll()：如果没有元素，直接返回null；如果有元素，出队 take()：如果队列空了，一直阻塞，直到队列不为空或者线程被中断–&gt;阻塞 poll(long timeout, TimeUnit unit)：如果队列不空，出队；如果队列已空且已经超时，返回null；如果队列已空且时间未超时，则进入等待，直到出现以下三种情况： 被唤醒 等待时间超时 当前线程被中断</p>
<p>4、ArrayBlockingQueue与LinkedBlockingQueue对比 ArrayBlockingQueue： 一个对象数组+一把锁+两个条件 入队与出队都用同一把锁 在只有入队高并发或出队高并发的情况下，因为操作数组，且不需要扩容，性能很高 采用了数组，必须指定大小，即容量有限 LinkedBlockingQueue： 一个单向链表+两把锁+两个条件 两把锁，一把用于入队，一把用于出队，有效的避免了入队与出队时使用一把锁带来的竞争。 在入队与出队都高并发的情况下，性能比ArrayBlockingQueue高很多 采用了链表，最大容量为整数最大值，可看做容量无限</p>
<p>1、原子类 可以实现一些原子操作 基于CAS 下面就以AtomicInteger为例。 2、AtomicInteger 在没有AtomicInteger之前，对于一个Integer的线程安全操作， 是需要使用同步锁来实现的，当然现在也可以通过ReentrantLock来实现， 但是最好最方便的实现方式是采用AtomicInteger。</p>
<p>注意： value是volatile的，关于volatile的相关内容见《附2 volatile》，具体链接：http://www.cnblogs.com/java-zhao/p/5125698.html 单步操作： 例如set()是直接对value进行操作的，不需要CAS，因为单步操作就是原子操作。 多步操作： 例如getAndSet(int newValue)是两步操作–&gt;先获取值，在设置值，所以需要原子化， 这里采用CAS实现。 对于方法是返回旧值还是新值，直接看方法是以get开头（返回旧值）还是get结尾（返回新值）就好 CAS： 比较CPU内存上的值是不是当前值current，如果是就换成新值update，如果不是， 说明获取值之后到设置值之前，该值已经被别人先一步设置过了，此时如果自己再设置值的话， 需要在别人修改后的值的基础上去操作，否则就会覆盖别人的修改，所以这个时候会直接返回false， 再进行无限循环，重新获取当前值，然后再基于CAS进行加减操作。 如果还是不懂CAS，类比数据库的乐观锁。</p>
<p>ThreadPoolExecutor使用 + 工作机理 + 生命周期 5、线程池生命周期 创建之初，状态为RUNNNG 调用了ExecutorService#shutdown： 调用了ExecutorService#shutdownNow： 1、Executors与ThreadPoolExecutor ThreadPoolExecutor 可以灵活的自定义的创建线程池，可定制性很高 想创建好一个合适的线程池比较难 使用稍微麻烦一些 实际中很少使用 Executors 可以创建4种线程池，这四种线程池基本上已经包含了所有需求，将来根据业务特点选用就好 使用非常简单 实际中很常用</p>
<pre><code>newFixedThreadPool(int corePoolSize)
    创建一个线程数固定（corePoolSize==maximumPoolSize）的线程池
    核心线程会一直运行
    如果一个核心线程由于异常跪了，会新创建一个线程
    无界队列LinkedBlockingQueue
newSingleThreadExecutor
    创建一个线程数固定（corePoolSize==maximumPoolSize==1）的线程池
    核心线程会一直运行
    无界队列LinkedBlockingQueue
    所有task都是串行执行的（即同一时刻只有一个任务在执行）
newCachedThreadPool
    corePoolSize==0
    maximumPoolSize==Integer.MAX_VALUE
    队列：SynchronousQueue
    创建一个线程池：当池中的线程都处于忙碌状态时，会立即新建一个线程来处理新来的任务
    这种池将会在执行许多耗时短的异步任务的时候提高程序的性能
    6秒钟内没有使用的线程将会被中止，并且从线程池中移除，因此几乎不必担心耗费资源
newScheduledThreadPool(int corePoolSize)
    用于执行定时或延迟执行的任务，最典型的：异步操作时的超时回调</code></pre>
<p>总结： 四种线程池最常用的就是newCachedThreadPool和newFixedThreadPool(int corePoolSize) 对于newScheduledThreadPool(int corePoolSize)使用比较少， 因为在现代开发中，如果用于去开发定时任务程序的话，用spring定时器会非常简单</p>
<p>第十五章 线程池的选用与线程数的指定 1、选用的两个角度 高性能：将提交到线程池中的任务直接交给线程去处理（前提：线程数小于最大线程数），不入队 缓冲执行：希望提交到线程池的任务尽量被核心线程（corePoolSize）执行掉 2、高性能 队列：SynchronousQueue 最大线程数：一般设为Integer.MAX_VALUE（整数最大值），防止回绝任务 典型案例：newCachedThreadPool 尤其适合于执行耗时短的任务 注意： 设置好闲置失效时间，keepAliveTime，用于避免资源大量耗费 对于出现大量耗时长的任务，容易造成线程数迅速增加，这种情况要衡量使用该类线程池是否合适 3、缓冲执行</p>
<pre><code>队列：LinkedBlockingQueue和ArrayBlockingQueue
典型案例：newFixedThreadPool(int threadSize)
注意：
    使用该类线程池，最好使用LinkedBlockingQueue（无界队列），
    但是当大量并发任务的涌入，导致核心线程处理不过来，队列元素会大量增加，可能会报内存溢出
    当然，对于上边这种情况的话，如果是ArrayBlockingQueue的话，如果设置得当，可以回绝一些任务，而不报内存溢出</code></pre>
<p>4、线程数的确定 公式：启动线程数=[任务执行时间/(任务执行时间-IO等待时间)]*CPU核数 注意： 如果任务大都是CPU计算型任务，启动线程数=CPU核数 如果任务大多需要等待磁盘操作，网络响应，启动线程数可以参照公式估算，当然&gt;CPU核数 总结： 一般使用线程池，按照如下顺序依次考虑（只有前者不满足场景需求，才考虑后者）： newCachedThreadPool–&gt;newFixedThreadPool(int threadSize)–&gt;ThreadPoolExecutor newCachedThreadPool不需要指定任何参数 newFixedThreadPool需要指定线程池数（核心线程数==最大线程数） ThreadPoolExecutor需要指定核心线程数、最大线程数、闲置超时时间、队列、队列容量，甚至还有回绝策略和线程工厂 对于：newFixedThreadPool和ThreadPoolExecutor的核心数可以参照上述给出的公式进行估算。</p>

                                
                            </article>

                    </div>
            </div>

        <!-- Scripts -->
            <script src="assets/js/jquery.min.js"></script>
            <script src="assets/js/jquery.scrollex.min.js"></script>
            <script src="assets/js/jquery.scrolly.min.js"></script>
            <script src="assets/js/browser.min.js"></script>
            <script src="assets/js/breakpoints.min.js"></script>
            <script src="assets/js/util.js"></script>
            <script src="assets/js/main.js"></script>

    </body>
</html>