<!DOCTYPE HTML>
<html>
	<head>
		<title>java 36</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">
			<div id="wrapper" class="fade-in">
					<div id="intro">
						<h1>This is<br />
						java </h1>
						<p>article of java  <a href="http://blankcat.github.io/">@BlankCat</a> for <a href="http://blankcat.github.io/">Home page</a><br />
						address:<a href="http://blankcat.github.io/">http://blankcat.github.io/</a>.</p>
						<ul class="actions">
							<li><a href="#header" class="button icon solo fa-arrow-down scrolly">Continue</a></li>
						</ul>
					</div>
					<header id="header">
						<a href="index.html" class="logo">BlankCat</a>
					</header>
						<!-- Nav -->
					<nav id="nav" style="overflow-x: scroll;">
						<ul class="links">
							<li class="active"><a href="index.html">01</a></li>
							<li><a href="02.html">02</a></li>
							<li><a href="03.html">03</a></li>
							<li><a href="04.html">04</a></li>
							<li><a href="05.html">05</a></li>
							<li><a href="06.html">06</a></li>
							<li><a href="07.html">07</a></li>
							<li><a href="08.html">08</a></li>
							<li><a href="09.html">09</a></li>
							<li><a href="10.html">10</a></li>
							<li><a href="11.html">11</a></li>
							<li><a href="12.html">12</li>
							<li><a href="13.html">13</a></li>
							<li><a href="14.html">14</a></li>
							<li><a href="15.html">15</a></li>
							<li><a href="16.html">16</a></li>
							<li><a href="17.html">17</a></li>
							<li><a href="18.html">18</a></li>
							<li><a href="19.html">19</a></li>
							<li><a href="20.html">20</a></li>
							<li><a href="21.html">21</a></li>
							<li><a href="22.html">22</a></li>
							<li><a href="23.html">23</li>
							<li><a href="24.html">24</a></li>
							<li><a href="25.html">25</a></li>
							<li><a href="26.html">26</a></li>
							<li><a href="27.html">27</a></li>
							<li><a href="28.html">28</a></li>
							<li><a href="29.html">29</a></li>
							<li><a href="30.html">30</a></li>
							<li><a href="31.html">31</a></li>
							<li><a href="32.html">32</a></li>
							<li><a href="33.html">33</a></li>
							<li><a href="34.html">34</a></li>
							<li><a href="35.html">35</a></li>
							<li><a href="36.html">36</a></li>
							<li><a href="37.html">37</a></li>
							<li><a href="38.html">38</a></li>
							<li><a href="39.html">39</a></li>
							<li><a href="40.html">40</a></li>
						</ul>
						<ul class="icons">
							<li><a href="https://github.com/BlankCat" class="icon fa-github"><span class="label">GitHub</span></a></li>
						</ul>
					</nav>
					<div id="main">
							<article class="post featured">
								<p>11-java提供io方式-nio如何实现多路复用? nio多路复用的局限性？ 遇到的场景？</p>
<p>NIO的全称是NoneBlocking IO，非阻塞IO，（同步非阻塞） 区别于BIO，BIO的全称是Blocking IO，阻塞IO（同步阻塞） 传统多线程服务器是 BIO （同步阻塞） 请求处理过程【链接/读/写】 Accept是阻塞的，只有新连接来了，Accept才会返回，主线程才能继 Read是阻塞的，只有请求消息来了，Read才能返回，子线程才能继续处理 Write是阻塞的，只有客户端把消息收了，Write才能返回，子线程才能继续读取下一个请求</p>
<p>IO多路复用 NIO并不是Java独有的概念，NIO代表的一个词汇叫着IO多路复用 它是由操作系统提供的系统调用，早期这个操作系统调用的名字是select【轮询】，但是性能低下， 后来渐渐演化成了Linux下的epoll和Mac里的kqueue。 0. 概述 1.Java NIO 2.Channel Channel到Channel的数据传输 transferFrom() transferTo() 3.Buffer Buffer的基本使用 Buffer的 capacity, position 和limit Buffer常用方法 1.申请一个Buffer 2.写入数据到buffer中 3.flip()写切换到读 4.从buffer中读取数据 5.倒回rewind() 6.clear()和compact() 7.mark()和reset() 8.equals() 9.Scatter和Gather 3.Selector 1.创建Selector 2.注册Channel 3.SelectionKey对象 4.通过Selector选择Channel 5.selectionKey() 6.wakeUp() 7.close()</p>
<p>Channels和Buffers： 在标准IO接口中我们最常用的是字节流（byte strams）和字符流（character streams）。 在NIO接口中我们需要使用Channel和Buffer进行IO操作， Channel模拟了流的概念，但是又有不同。 数据总是从一个Channel读到一个buffer中， 或者从一个buffer中写到channel中。</p>
<p>Non-blocking IO： Java NIO接口的核心就是提供了非阻塞IO的能力（Non-blocking IO）。 例如：一个线程可以请求channel读取数据到buffer中， 在channel读取数据的过程中，线程可以处理其他的事情， 一旦数据已经读取到buffer中，线程可以继续处理buffer中的数据； 对于将buffer中的数据写到channel中道理是一样的。 Selectors： Java NIO包含了Selectors的设计，Selector通过事件驱动多个Channel的对象， Selector可以实现让一个线程管理使用多个数据的Channel。 * FileChannel 可以读写文件中的数据 * DatagramChannel 可以通过UDP协议读写数据 * SocketChannel 可以通过TCP协议读写数据 * ServerSocketChannel 允许我们像一个web服务器那样监听TCP链接请求，为每一个链接请求创建一个SocketChannel</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>Buffer的 capacity容量, position位置 和limit最大容量</p>
<p>Selector是Java NIO中用于管理一个或多个Channel的组件， 控制决定对哪些Channel进行读写； 通过使用Selector让一个单线程可以管理多个Channel甚至多个网络连接。 thread Selector 管理多个channel channel1 chennel2 channel3</p>
<p>由于nio实际上是同步非阻塞io，是一个线程在同步的进行事件处理，当一组事channel处理完毕以后， 去检查有没有又可以处理的channel。这也就是同步+非阻塞。 同步，指每个准备好的channel处理是依次进行的， 非阻塞，是指线程不会傻傻的等待读。 只有当channel准备好后，才会进行。 那么就会有这样一个问题，当每个channel所进行的都是耗时操作时， 由于是同步操作，就会积压很多 channel 任务，从而完成影响。 那么就需要对nio进行类似负载均衡的操作， 如用线程池去进行管理读写，将channel分给其他的线程去执行， 这样既充分利用了每一个线程，又不至于都堆积在一个线程中，</p>
<p>（*****） B和N通常是针对数据是否就绪的处理方式来 sync和async是对阻塞进行更深一层次的阐释， 区别在于【数据拷贝由用户线程完成还是内核完成】， 讨论范围一定是两个线程及以上了。</p>
<p>同步阻塞，从数据是否准备就绪到数据拷贝都是由用户线程完成 【同步io BIO】</p>
<p>同步非阻塞，数据是否准备就绪由内核判断，数据拷贝还是用户线程完成 【 NIO我们常说的异步io】</p>
<p>异步非阻塞，数据是否准备就绪到数据拷贝都是内核来完成</p>
<p>所以真正的异步IO一定是非阻塞的。</p>
<p>多路复用IO即使有 Reactor 通知用户线程也是同步IO范畴，因为数据拷贝期间仍然是用户线程完成。</p>
<p>所以假如我们没有内核支持数据拷贝的情况下，讨论的非阻塞并不是彻底的非阻塞，也就没有引入sync和async讨论的必要了</p>
<p>不知道这样理解是否正确</p>
<p>Reactor模式 Reactor是网络编程中的一种设计模式 Reactor是建立在多路io复用基础上的 事件驱动【网络事件：链接/读操作/写操作】 传统的经历了3个过程 同步阻塞-一个链接过来，一个一个处理 while(true){ socket = accept(); handle(socket) }</p>
<p>改进 多线程 while(true){ socket = accept(); new thread(socket); } 提高链接的吞吐量，但是每一个socket都是阻塞的， 所以在一个线程里只能处理一个socket， 就算accept了多个也没用， 前一个socket被阻塞了， 后面的是无法被执行到的。 频繁的创建线程： 那么缺点在于资源要求太高，系统中创建线程是需要比较高的系统资源的， 如果连接数太高，系统无法承受，而且， 线程的反复创建-销毁也需要代价</p>
<p>改进io多路复用Reactor模式 线程池（卡线程数量）+线程粒度控制+事件驱动（handler） 线程池的数目卡连接数，设置一个最大值， 而且线程池本身可以缓解线程创建-销毁的代价， 这样优化确实会好很多， 不过还是存在一些问题的 hanlder+event handler会出处理一种event 全局的管理者selector，我们需要把channel注册感兴趣的事件， 那么这个selector就会不断在channel上检测是否有该类型的事件发生， 如果没有，那么主线程就会被阻塞，否则就会调用相应的事件处理函数即handler来处理。 典型的事件有连接，读取和写入，当然我们就需要为这些事件分别提供处理器， 每一个处理器可以采用线程的方式实现。</p>
<p>Reactor需要底层函数的支持，在java中就是NIO的select函数了， 这个函数可以监听多个套接字， 如果都没有事件产生，就会阻塞， 否则就会返回一个套接字的set， 每一个套接字都会关联一个发生的事件。 这项技术叫做多路io复用， 不同的平台都有各自的支持。 所以Reactor是建立在多路io复用基础上的</p>
<p>Reactor拆成两个角色Main Reactor及Sub Reactor Main Reactor：负责监听外部的连线请求， 并派发给Acceptor处理。 故Main Reactor中的selector只有注册OP_ACCEPT事件， 也只能监听OP_ACCEPT事件。 Acceptor接受连线后会给client绑定一个Handler并注册IO事件到Sub Reactor上监听， 对于有多个Sub Reactor的情况下， IO事件选择注册给哪个Sub Reactor则是采用Round-robin的机制来分配。</p>
<p>Sub Reactor： 負責監聽IO事件，並派發IO事件給Handler處理。 Sub Reactor線程的數量可以設置為CPU核心數。</p>
<p>批评NIO确实要小心，我觉得主要是三方面， 首先是如果是从写BIO过来的同学，需要有一个巨大的观念上的转变， 要清楚网络就是并非时刻可读可写，我们用NIO就是在认真的面对这个问题， 别把channel当流往死里用，没读出来写不进去的时候，就是该考虑让度线程资源了， 第二点是NIO在不同的平台上的实现方式是不一样的，如果你工作用电脑是win，生产是linux，那么建议直接在linux上调试和测试， 第三点，概念上的，理解了会在各方面都有益处，NIO在IO操作本身上还是阻塞的，也就是他还是同步IO， AIO读写行为的回调才是异步IO，而这个真正实现，还是看系统底层的，写完之后，我觉得我这一二三有点凑数的嫌疑 回复 不错，不过，在非常有必要之前，不见得都要底层，毕竟各种抽象， 都是为特定领域工程师准备的，JMM等抽象都是为了大家有个清晰的、不同层面的高效交流</p>
<p></p>
<p>IO的调用可以分为三大块， 请求调用， 逻辑处理， 响应返回处理。 常规的BIO在这三个阶段会串行的阻塞的。NIO其实可以理解为将这三个阶段尽可能的去阻塞或者减少阻塞。 看了上面的例子，NIO的服务器端在接受客户端请求的时候，是单线程执行的， 而BIO是多线程处理的。但是不管咋的，他们服务器端处理具体的客户业务逻辑是都要用多线程的吧？</p>
<p>看nio代码部分，请求接受和处理都是一个线程在做。 这样的话，如果有多个请求过来都是按顺序处理吧， 其中一个处理时间比较耗时的话那所有请求不都卡住了吗？ 如果把nio的处理部分也改成多线程会有什么问题吗 回复 这种情况需要考虑把耗时操作并发处理， 再说处理是费cpu， 还是重io， 需要不同处理；如果耗时操作非常多，就不符合这种模型的适用场景</p>
<p>不太明白：BufferedInputStream和普通的InputStream直接read到一个缓冲数组这两种方式有什么区别？ 回复 我理解是bufferedIS是内部预读，所以两个buffer的意义不一样，前面是减少磁盘之类操作</p>
<p>管道到select上，应该用队列实现的吧？ 开启一个线程大概需要多少内存开销呢，我记得数据库连接大概2M 回复 线程看定义stack大小等，32、64位都不一样</p>
<p>多路复用IO，当出现有的IO请求在数据拷贝阶段， 会出现由于资源类型过份庞大而导致线程长期阻塞， 最后造成性能瓶颈的情况 回复 对</p>
<p>这里Nio的Selector只注册了一个sever chanel，这没有实现多路复用吧，多路复用不是注册了多个channel ，处理就绪的吗？而且处理客户端请求也是在同线程内，这还不如上面给的Bio解决方案吧 2018-06-02  作者回复</p>
<p>select在单线程下处理监听任务是否会成为瓶颈？能否通过创建多个select实例，并发监听socket事件呢？ 回复 Doug Lea曾经推荐过多个Selector，也就是多个reactor，如果你是这意思</p>
<p>我也自己写过一个基于nio2的网络程序，觉得配合futrue写起来很舒服。 仓库地址：https://github.com/LoranceChen/RxSocket 欢迎相互交流开发经验～ 记得在netty中，有一个搁置的netty5.x项目被废弃掉了， 原因有一点官方说是性能提升不明显，这是可以理解的， 因为linux下是基于epoll，本质还是select操作。 听了课程之后，有一点印象比较深刻，select模式是使用一个线程做监听， 而bio每次来一个链接都要做线程切换，所以节省的时间在线程切换上， 当然如果是c/c++实现，原理也是一样的。</p>
<p>想问一个一直困惑的问题，select内部如何实现的呢？ 个人猜测：不考虑内核，应用层的区分，单纯从代码角度考虑，我猜测， 当select开始工作时，有一个定时器， 比如每10ms去检查一下网络缓冲区中是否有tcp的链接请求包，然后把这些包筛选出来， 作为一个集合（即代码中的迭代器）填入java select类的一个集合成员中， 然后唤醒select线程，做一个while遍历处理链接请求， 这样一次线程调度就可以处理10ms内的所有链接。与bio比， 节省的时间在线程上下文切换上。不知道这么理解对不对。 另外，也希望能出一个课程，按照上面这种理解底层的方式， 讲讲select（因为我平常工作在linux机器，所以对select epoll比较感兴趣） 如何处理read，write操作的。谢谢～</p>
<p>回复 坦白说，内核epoll之类实现细节目前我的理解也有限</p>
<p>NIO多路复用模式，如果对应事件的处理比较耗时，是不是会导致后续事件的响应出现延迟。 回复 所以我理解，适用于大量请求大小有限的场景， （主任务）单线程模型，比如nodejs都有类似情况，</p>
<p>作者对同步/异步， 阻塞/非阻塞的概念说明存在问题。</p>
<p>《操作系统（第9版）》中关于 进程通信中有对这部分概念做过解释， 在进程间通信的维度， 同步和阻塞，异步和非阻塞是相同的概念。 进程通信（网络间通信也属于跨进程通信，在同一台pc，跨应用数据进程间通信）</p>
<p>沿着作者的概念解释简单推论一下就可以发现: 如果同步操作是需要等待调用返回才能进行下一步， 显然这个调用是阻塞的。</p>
<p>反之， 不需要等待调用返回的接口， 必然需要提供事件， 回调等机制，这种调用显然是非阻塞的。</p>
<p>回复 这东西并没有完全共识，概念定义要看上下文， 很多情况下可以算是同等，但在网络IO编程中是区分的， 本文的关注点就是这个</p>
<p>cpu运算密集型应用。node得诟病</p>
<p>把你给的NIOServer的例子做了一下， 发现sayHelloWorld()方法， client.write()后， 如果没有client.close(), 线程一直在挂着。请确认一下，是否例子缺了client.close()？ 回复 try with resource就相当于在finally里close； 一直挂着是因为server在伺服</p>
<p>java nio的selector主要的问题是效率，当并发连接数达到数万甚至数十万的时候 ，单线程的selector会是一个瓶颈；另一个问题就是再线上运行过程中经常出现cpu占用100%的情况， 原因也是由于selector依赖的操作系统底层机制bug 导致的selector假死， 需要程序重建selector来解决，这个问题再jdk中似乎并没有很好的解决， netty成为了线上更加可靠的网络框架。不知理解的是否正确，请老师指教。 回复 嗯，有局限性；那个epoll的bug应该在8里修了， netty的改进不止那些，它为了性能改了很多底层， 后面会介绍，好多算是hack；另外nio的目的是通用场景的基础API， 和终端应用有个距离，核心类库很多都是如此定位，netty这种开源框架更贴近用户场景</p>
<p>nio server 的例子有点简单哦，能否帮忙补充下生产环境下，io 密集型，和cpu 密集型场景的代码示例</p>
<p>1,基于nio的tcp 编程代码复杂 2,nio本质是同步非阻塞的 总结：select模式是使用一个线程做监听，而bio每次来一个链接都要做线程切换，所以节省的时间在线程切换</p>
<p>NIO适用于CPU密集并且操作的数据量不会很大场景。因为NIO只用一个线程来操作IO，所以避免了多线程切换带来的开销。 2018-07-25</p>
<p>我认为这个nio 2基于事件编程就跟swing 编程添加监听事件一样， 有事件发生了，执行回调函数。不知道理解是否准确。 时针对nio的采用线程不断地轮询，对客户多量大后会有响应延迟， 并发数量有限。同时也想知道tomcat是怎么样通过nio 来解决着问题的。 一直没有时间看一下他的源码，枉费我工作这么多年。老师可以写一篇这个nio和tomcat的文章！</p>
<p>问个问题，看到你写的样例中，几处try (),小括号里面写了一些逻辑，这种写法跟放在{}里面有啥区别？望专家回复一下。 回复 前面介绍过，try-with-resources，自动close</p>
<p>这个模式和go中的goroutine，channel，select很像，值得研究。</p>
<p>java 高性能异步网 Web框架 netty netty整合springMVC，实现高效的HTTP服务请求 python 高性能异步网 Web框架</p>

								
							</article>

					</div>
			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>