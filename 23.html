<!DOCTYPE HTML>
<html>
	<head>
		<title>java 36</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">
			<div id="wrapper" class="fade-in">
					<div id="intro">
						<h1>This is<br />
						java </h1>
						<p>article of java  <a href="http://blankcat.github.io/">@BlankCat</a> for <a href="http://blankcat.github.io/">Home page</a><br />
						address:<a href="http://blankcat.github.io/">http://blankcat.github.io/</a>.</p>
						<ul class="actions">
							<li><a href="#header" class="button icon solo fa-arrow-down scrolly">Continue</a></li>
						</ul>
					</div>
					<header id="header">
						<a href="index.html" class="logo">BlankCat</a>
					</header>
						<!-- Nav -->
					<nav id="nav" style="overflow-x: scroll;">
						<ul class="links">
							<li class="active"><a href="index.html">01</a></li>
							<li><a href="02.html">02</a></li>
							<li><a href="03.html">03</a></li>
							<li><a href="04.html">04</a></li>
							<li><a href="05.html">05</a></li>
							<li><a href="06.html">06</a></li>
							<li><a href="07.html">07</a></li>
							<li><a href="08.html">08</a></li>
							<li><a href="09.html">09</a></li>
							<li><a href="10.html">10</a></li>
							<li><a href="11.html">11</a></li>
							<li><a href="12.html">12</li>
							<li><a href="13.html">13</a></li>
							<li><a href="14.html">14</a></li>
							<li><a href="15.html">15</a></li>
							<li><a href="16.html">16</a></li>
							<li><a href="17.html">17</a></li>
							<li><a href="18.html">18</a></li>
							<li><a href="19.html">19</a></li>
							<li><a href="20.html">20</a></li>
							<li><a href="21.html">21</a></li>
							<li><a href="22.html">22</a></li>
							<li><a href="23.html">23</li>
							<li><a href="24.html">24</a></li>
							<li><a href="25.html">25</a></li>
							<li><a href="26.html">26</a></li>
							<li><a href="27.html">27</a></li>
							<li><a href="28.html">28</a></li>
							<li><a href="29.html">29</a></li>
							<li><a href="30.html">30</a></li>
							<li><a href="31.html">31</a></li>
							<li><a href="32.html">32</a></li>
							<li><a href="33.html">33</a></li>
							<li><a href="34.html">34</a></li>
							<li><a href="35.html">35</a></li>
							<li><a href="36.html">36</a></li>
							<li><a href="37.html">37</a></li>
							<li><a href="38.html">38</a></li>
							<li><a href="39.html">39</a></li>
							<li><a href="40.html">40</a></li>
						</ul>
						<ul class="icons">
							<li><a href="https://github.com/BlankCat" class="icon fa-github"><span class="label">GitHub</span></a></li>
						</ul>
					</nav>
					<div id="main">
							<article class="post featured">
								<p>23-类的加载过程-双亲委派模型 jar hell 问题？如何解决的？</p>
<p>IOC和AOP原理</p>
<p>还能再讲讲ORM映射的细节吗？</p>
<p>启动类加载器（Bootstrap ClassLoader）： 由C++语言实现（针对HotSpot）, 负责将存放在<JAVA_HOME>-Xbootclasspath参数指定的路径中的类库加载到内存中。</p>
<p>其他类加载器： 由Java语言实现，继承自抽象类ClassLoader。如：</p>
<p>扩展类加载器（Extension ClassLoader）： 负责加载<JAVA_HOME>.ext.dirs系统变量指定的路径中的所有类库。 应用程序类加载器（Application ClassLoader）。 负责加载用户类路径（classpath）上的指定类库， 我们可以直接使用这个类加载器。一般情况，、 如果我们没有自定义类加载器默认就是用这个加载器。</p>
<p>Bootstrap ClassLoader Extension ClassLoader Application ClassLoader 自定义ClassLoader 子类都会委托父类，先去尝试加载类，加载不到，再用子类加载器去加载</p>
<p>Jar hell jar包冲突，对于大项目或没有maven的项目是比较麻烦的。 1 应用无法启动 2 编译时没问题，运行时报错。 解决方法: 1 改为maven 项目，使包的管理和依赖可视化 2 在1的基础上，解决明显的包编译冲突 3 根据运行时报错找到冲突的包，或者要排除的包 回复 不错</p>
<p>“双亲委派模型”完全是错误的翻译，麻烦老师纠正。 在《深入java虚拟机》这本书里，翻译的“双亲委派模型”， 英文是parents delegation model。 参考国外网站，都是parent delegation model 或 者classloader delegation model， 翻译过来也应该是“单亲委派模型”或者类加载器委派模型， 再看看实际的结构图， 根本没有提现什么“双亲”，绝对是“单亲委派模型”啊！ 这么一个小小的错误，整个行业里都“继承”着，这是不是一种悲哀？</p>
<p>两个war依赖相同的jar包，部署在同一个tomcat，类会重复加载吗？ 回复 没有深入研究Tomcat类加载，逻辑上，这种不应该是可选吗？ 要么共享，要么各自一份，各有利弊的样子</p>
<p>老师能否讲讲一般什么场景下需要自定类加载， 有什么好处，为什么不用其他方式解决， 比如jar hell,此问题可以通过其他方式直接解决， 有的评论提到自定义类加载，我并不认为是比较好的解决方式。</p>
<p>当一个类或一个资源文件存在多个jar中，就会出现jar hell问题。</p>
<p>可以通过以下代码来诊断方案： try { ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); String resourceName = “net/sf/cglib/proxy/MethodInterceptor.class”; Enumeration<URL> urls = classLoader.getResources(resourceName); while(urls.hasMoreElements()){ System.out.println(urls.nextElement()); } } catch (IOException e) { e.printStackTrace(); }</p>
<p>输出结果：jar:file:/D:/workspace/Test/lib/cglib-3.2.4.jar!/net/sf/cglib/proxy/MethodInterceptor.class</p>
<p>jar hell 就是一个类存在不同的jar包中， 解决办法就是自己加载手动通过cassloader加载类</p>
<p></p>
<p>jdk现在的更新模式变了，jdk9是不稳定版本，还需要研究吗？ 是不是只学习LTS的版本就好了 回复 这些版本是连续的，不会浪费，lts确实是未来升级的待选，可以作为重点</p>
<p>Jar hell jar包冲突，对于大项目或没有maven的项目是比较麻烦的。 1 应用无法启动 2 编译时没问题，运行时报错。 解决方法: 1 改为maven 项目，使包的管理和依赖可视化 2 在1的基础上，解决明显的包编译冲突 3 根据运行时报错找到冲突的包，或者要排除的包</p>
<p>使用委派模型具体是怎么避免重复加载java类型的？ 回复 同一加载器不能重复加载某个类型，既然都尽量委派给父加载器，除非它加载不了，不然就只有一份</p>
<p>Jar Hell问题：当一个类或一个资源文件存在多个jar中， 就会出现Jar Hell问题。这不就是我们平常说的jar包冲突?</p>
<p>网上的解决方案都是通过写一段 类加载代码将冲突的类、jar包打印出来。 平常我自己的话， 会利用Eclipse、IDEA里的显示jar包加载结构的插件来检查出冲突的jar。</p>

								
							</article>

					</div>
			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>